# 8.虚拟机

通常而言，应用程序直接运行在PC或服务器的操作系统上。每台PC或服务器在同一时间只运行一个操作系统。因此，应用程序供应商需要为每个操作系统或平台重写应用程序的部分代码，才能使应用能够得到系统支持的运行。要支持多种操作系统，应用程序供应商需要创建、管理和维护多种硬件与操作系统基础设施，这一过程需要耗费昂贵的代价和大量的资源。处理这个问题的有效策略之一称为虚拟化(virtualization)，虚拟化技术可使一台PC或服务器同时运行多个操作系统或一个系统的多个会话。一台运行虚拟化软件的机器能在同一平台上运行大量的应用程序，包括那些运行在不同操作系统上的应用程序。实际上，主机操作系统能支持多个虚拟机(virtual machines)，每个虚拟机都有特定操作系统的特性。 

启用虚拟化的解决方案是虚拟机监视器(VMM),现在通常称为虚拟机管理程序(Hypervisor)。该软件介于硬件和虚拟机之间，以资源代理的形式存在。简而言之，它使多个虚拟机安全地共存于一台物理服务器主机并共享主机的资源。



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/virtual_1.png?raw=true)



## Java虚拟机



尽管Java虚拟机（JVM）用“虚拟机”作为其名称的一部分，但其实现和用途与我们前面所讲的模型不同。虚拟机管理程序支持在主机上运行一个或多个虚拟机。这些虚拟机独立的处理工作负载，支持操作系统和应用，且在它们自身看来，访问一系列提供计算、存储和输入/输出的资源。Java虚拟机的目的是，无须更改任何Java代码就可在任意硬件平台的任意操作系统上，提供运行时空间。两种模型的目的都是通过使用某种程度的抽象化来实现平台无关性。       

JVM可描述为一个抽象的计算设备，它包含指令集、一个PC（程序计数器）寄存器、一个用来保存变量和结果的栈、一个保存运行时数据和垃圾手机的堆、一个存储代码和常量的方法区。 

JVM支持多个线程，每个线程都有自己的寄存器和堆栈区，且所有线程共享栈和方法区。



## Android虚拟机



Android平台的虚拟机称为Dalvik，Dalvik VM(DVM)执行格式为Dalvik Executable(.dex格式)的文件，即为高效存储和内存映射执行而优化的格式。DVM可以运行由Java编译器编译的类，该编译器以用“dx”工具转换为本地格式。

虚拟机运行在Linux内核的顶部，它依赖于底层的功能（如线程和底层的内存管理）。Dalvik核心类库的目的是，为那些使用标准Java编程的人员提供熟悉的开发环境，但它是专门为满足小型移动设备的需要而设计的。



每个Android应用程序都运行在自己的进程中，有自己的Dalvik运行实例。Dalvik是可以在一台设备上高效执行多个副本的虚拟机。 





### dex文件系统

DVM运行Java语言的应用和代码。标准的Java编译器将源代码（写在文本文件中）转换为字节码，然后将字节码翻译成DVM虚拟机可读和可用的.dex文件。本质上，类文件被转换为.dex文件(像Java虚拟机中的jar文件)，然后在DVM上读取和执行。类文件中的重复数据在.dex文件中只包含一次，以节省空间开销。在安装时，这个可执行文件还可根据移动设备进一步修改和优化。



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/java_vs_dalvik.png?raw=true)

上图中的.jar文件的布局，它包含一个或多个类文件。这些类文件聚合为一个.dex文件，并存储为一个android安装包文件(.apk)。所有类文件中的不同常量池集中为单个常量池，在.dex文件中组织为常量类型。允许类的常量池共享，因此可使常量值的重复减至最低。类似的，类文件中的类、域、方法、属性也在.dex文件中集中到一起。





## Android进程结构

如同传统的Linux系统一样，Android的第一个用户空间进程是init，它是所有其他进程的根。然而，Android的init启动的守护进程是不同的，这些守护进程更多的聚焦于底层细节（管理文件系统和硬件访问），而不是高层用户设施，例如调度定时任务。Android还有一层额外的进程，它们运行Dalvik的Java语言环境，负责执行系统中所有以Java实现的部分。



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_process.png?raw=true)



如上图，首先是init进程，它产生了一些底层守护进程。其中一个守护进程是zygote，它是高级Java语言进程的根。Android的init不以传统的方法运行shell，因为典型的Android设备没有本地控制台用于shell访问。作为替代，系统进程adbd监听请求shell访问的远程连接（例如通过USB），按要求为它们创建shell进程。因为Android大部分是用Java语言编写的，所以zygote守护进程以及由它启动的进程是系统的中心。由zygote启动的第一个进程称为system_server，它包含全部核心操作服务，其关键部分是电源管理、包管理、窗口管理和活动管理。

其他进程在需要的时候由zygote创建。这些进程中有一些是“持久的”进程，它们是基本操作系统的组成部分，例如phone进程中的电话栈，它必须保持始终运行。另外的应用程序进程将在系统运行的过程中按需创建和终止。

应用程序通过调用操作系统提供的库与操作系统进行交互，这些库合起来构成Android框架（Android framework）。这些库中有一些可以在进程内部执行其工作，但是许多库需要与其他进程执行进程间通信，作者通常是在system_server进程中提供服务的。



### Zygote

Zygote是在启动时就运行在DVM上的一个进程。每当出现创建进程的请求时，Zygote就会产生一个新的DVM虚拟机。Zygote通过在内存中尽可能多的共享内容来最小化产生一个新DVM所消耗的时间。通常而言，许多应用程序都会使用核心库的类和相应的堆结构，而这些内容都是只读的。也就是说，被大部分应用程序使用的这些共享数据和类都是只读而不能改变的。因此，当Zygote加载时，就预加载和初始化了应用程序运行时可能用到的Java核心库和资源。当Zygote创建一个新的DVM时，这部分类不会被分配到新内存。Zygote只是简单地把子进程的这些内存页映射到父进程的相应位置。

实际上，几乎不需要更多的映射页。如果一个类被一个子进程自己的DVM改写，那么Zygote会将受影响的内存复制到子进程中。这种即写即复制的行为在使得最大化共享内存的同时，还能保证应用程序间不会相互影响，并在跨应用程序和进程的边界时保证安全性。



## Android进程模型



Linux的传统进程模型是用fork指令来创建新进程，然后用exec指令使用待运行的源码初始化该进程并开始执行。shell负责实现进程执行、创建新进程、执行所需的进程来运行shell指令。当指令结束时，进程被从Linux中移除。

Android使用的进程有些不同。活动管理器是Android负责正在运行的应用程序的管理的一部分。活动管理器协调新应用程序进程的启动，决定哪些应用程序能在其中运行，哪些已不再需要。



### 启动进程

为了启动新进程，活动管理器需要与zygote通信。活动管理器首先开始，它创建一个与zygote相连的专用接口，通过接口发送一条指令，表示它需要启动一个进程。这条指令主要描述需要创建的沙箱、新进程运行所需要的UID以及需要遵守的安全性制约。zygote需要作为根来运行：创建新进程时，它合理配置运行所需的UID，最终下放权限，将进程改为该UID。

![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_start_process.png?raw=true)

上图展示了一个新进程中启动活动的流程： 

1. 某个现有进程（如应用程序启动器）调用活动管理器，发出意图，描述它想要启动的新活动。
2. 活动管理器要求封装管理器将这个意图解析为一个明确的组件。
3. 活动管理器判断这个应用程序的进程并未正在运行，然后向zygote请求一个具有合适UID的新锦成。
4. zygote进行一次fork指令，克隆自己来创造一个新进程，下方权限并配置新进程的UID和沙箱，初始化该进程的Dalvik，使得Java runtime开始完全执行。例如，它需要在fork后启动垃圾收集等线程。
5. 新进程如今是一个zygote的克隆，并运行着完全配置好的Java环境。它回调活动管理器，询问后者“我该做什么”。
6. 活动管理器返回即将启动的应用程序的完整信息，如源码位置等。
7. 新进程读取应用程序的源码，开始运行。
8. 活动管理器将所有即将进行的操作发送给新进程，在此处为“启动活动X”。
9. 新进程收到指令，启动活动，实体化合适的Java类并执行。

注意，当活动启动时，应用程序的进程可能正在运行了。在这种情况下，活动管理器会直接跳转到末尾，向该进程发送一条新指令，让它实体化并执行合适的组件。如果合适，这会导致一个额外的活动实例在应用程序中运行。



### 进程声明周期

活动管理器也负责判断何时进程不再被需要。活动管理器记录一个进程中运行的所有活动、接收器、服务以及内容提供其，据此可判断该进程的重要程度。

Android内核中的内存溢出强制结束指令是使用一个进程的oom_adj进行严格排序，决定哪个进程需要优先强制结束。活动管理器负责基于每个进程的状态，通过将其归类于几个主要用途，从而合理设定器oom_adj。/proc/<pid>/oom_adj:   

- 取值是-17到+15，取值越高，越容易被干掉。如果是-17，则表示不能被kill
- 该设置参数的存在是为了和旧版本的内核兼容

![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_process_adj.png?raw=true)

让RAM内存不足时，系统已经完成了进程的配置，使得内存溢出强制结束命令优先中止缓存(cache)类型的进程，尝试重新取得足够的所需内存，随后中止界面(home)类别、服务(service)类别，以此类推。在同一个oom_adj水平中，它将优先中止内存占用较大的进程。






---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
