# 2.进程与线程



狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。

广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是[操作系统](https://baike.baidu.com/item/操作系统/192)动态执行的[基本单元](https://baike.baidu.com/item/基本单元)，在传统的[操作系统](https://baike.baidu.com/item/操作系统)中，进程既是基本的[分配单元](https://baike.baidu.com/item/分配单元)，也是基本的执行单元。

进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括[文本](https://baike.baidu.com/item/文本)区域（text region）、数据区域（data region）和[堆栈](https://baike.baidu.com/item/堆栈)（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有[处理](https://baike.baidu.com/item/处理)器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为[进程](https://baike.baidu.com/item/进程)。



进程是60年代初首先由[麻省理工学院](https://baike.baidu.com/item/麻省理工学院)的[MULTICS系统](https://baike.baidu.com/item/MULTICS系统)和IBM公司的[CTSS](https://baike.baidu.com/item/CTSS)/360系统引入的。

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的[代码](https://baike.baidu.com/item/代码)，还包括当前的活动，通过[程序计数器](https://baike.baidu.com/item/程序计数器)的值和处理[寄存器](https://baike.baidu.com/item/寄存器)的内容来表示。

进程由三部分组成: 

- 一段可执行的程序
- 程序所需要的相关数据(变量、工作空间、缓冲区等)
- 程序的执行上下文

最后一部分是根本。执行上下文(execution context)又称为进程状态(process state)，是操作系统用来管理和控制进程所需的内部数据。这种内部信息和进程是分开的，因为操作系统信息不允许被进程直接访问。上下文包括操作系统管理进程及处理器正确执行进程所需的所有信息，包括各种处理器寄存器的内容，如程序计数器和数据寄存器。它还包括操作系统使用的信息，如进程优先级及进程是否在等待I/O事件的完成。

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/cpu_process.png)

上图是一种进程管理方法。两个进程A和B存在与内存中的某些部分，给每个进程（包含程序、数据和上下文信息）分配了一块存储器区域，并且在由操作系统建立和维护的进程表中进行了记录。进程表包含记录每个进程的表项，表项内容包括指向包含进程的存储块地址的指针，还包括该进程的部分和全部上下文。执行上下文的其余部分存放在别处，可能和进程本身存在一起，通常还可能保存在内存中的一块独立区域。进程索引寄存器（process index register）包含当前正在控制处理器的进程在进程表中的索引。程序计数器（program counter）指向该进程中下一条待执行的指令。基址寄存器中保存该存储器区域的开始地址。

图中表示，进程索引寄存器表明进程B正在执行。以前执行的进程被临时中断，在A中断的同事，所有寄存器的内容被记录在其执行上下文环境中，以后操作系统就可以执行进程切换。恢复进程A的执行。进程切换过程中包括保存B的上下文和恢复A的上下文。在程序计数器中载入指向A的程序区域的值时，进程A自动恢复执行。

在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。严格来说，在某一个瞬间，CPU只能运行一个进程。但在1秒钟内，它可能运行多个进程，这样就产生并行的错觉。CPU在各进程之间来回切换，这种快速的切换称为多道程序设计。

## 多道程序设计模型

采用多道程序设计可以提高CPU利用率。严格地说，如果进程用于计算的平均时间是进程在内存中停留时间的20%，且内存中同时有5个进程，则CPU将一直满负载运行。然而，这个模型在现实中过于乐观，因为它假设这5个进程不会同时等待I/O。

更好的模型是从概率的角度来看CPU的利用率。假设一个进程等待I/O操作的时间与其停留在内存的时间比为p。当内存中同时有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率为p的n次方。

![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/duodao_module.png?raw=true)

从上图中可以看到，如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时在内存中。



## 进程的特性

1. 动态性

    动态性是进程的最基本特征，它是程序执行过程，它是有一定的生命期。它由创建而产生、由调度而执行，因得不到资源而暂停，并由撤消而死亡。而程序是静态的，它是存放在介质上一组有序指令的集合，无运动的含义。

2. 并发性

    并发性是进程的重要特征，同时也是OS的重要特征。并发性指多个进程实体同存于内存中，能在一段时间内同时运行。而程序是不能并发执行。

3. 独立性

    进程是一个能独立运行的基本单位，即是一个独立获得资源和独立调度的单位，而程序不作为独立单位参加运行。

4. 异步性

    进程按各自独立的不可预知的速度向前推进，即进程按异步方式进行，正是这一特征，将导致程序执行的不可再现性，因此OS必须采用某种措施来限制各进程推进序列以保证各程序间正常协调运行。



## 进程的状态



- 就绪态：进程做好了准备，只要有机会就开始执行
- 运行态：进程正在执行
- 堵塞/等待态：进程在某些事件发生前补鞥呢执行，如I/O操作完成
- 新建态：刚刚创建的进程，操作系统还未把他加入可执行进程组，它通常是进程控制块已经创建但还未加载到内存中的新进程
- 退出态：操作系统从可执行进程组中释放出的进程，要么它自身已停止，要么它因某种原因被取消

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/process_state.png)

### 挂起态

当内存中的所有进程都处于堵塞态时，操作系统可把其中的一个进程置为挂起态，并将它移到磁盘。此时内存所释放的空间就可被调入的另一个进程使用。操作系统执行换出操作后，将进程取到内存中的方式有两种：接纳一个新近创建的进程，或调入一个此前挂起的进程。显然，操作系统更倾向于调入一个此前挂起的进程，并为它服务，而非增加系统的总负载数。

挂起进程等价于不在内存中的进程。不在内存中的进程，不论他是否在等待一个时间，都不能立即执行。

### 进程由哪几部分组成？

进程是程序的一次运行过程，它是由程序段、数据段和进程控制块 PCB 组成的一个实体，其中：

- 程序段：对应程序的操作代码部分，用于描述进程所需要完成的功能。
- 数据段：对应程序执行时所需要的数据部分，包括数据，堆栈和工作区。
- 进程控制块(Process Control Block, PCB) ：描述进程的基本信息和运行状态，记录了进程运行时所需要的全部信息，它是进程存在的唯一标识，与进程一一对应。所谓的创建进程和撤销进程，都是指对 PCB 的操作。

#### 进程控制块

进程执行的任意时刻，都可由如下元素来表征:  

- 标识符:与进程相关的唯一标识符，用于标识、区分一个进程，通常有外部标识符和内部标识符两类。外部标识符通常是由字母、数字所组成的一个字符串，用户或其他进程访问该进程时使用。内部标识符是操作系统为每个进程赋予的唯一一个整数，是作为内部识别而设置的。
- 状态:若进程正在执行，则进程处于运行态。进程状态指明进程当前的状态，作为进程调度和对换时的依据；
- 优先级:相对于其他进程的优先顺序，说明进程使用CPU的优先级别，其中优先级高的进程将优先获得CPU。
- 程序计数器:程序中即将执行的下一条指令的地址
- 内存指针:包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针
- 上下文数据:进程执行时处理器的寄存器中的数据
- I/O状态信息:包括显式I/O请求、分配给进程的I/O设备和被进程使用的文件列表等
- 记账信息:包括处理器时间总和、使用的时钟数总和、时间限制、及账号等

上述列表信息存放在一个被称为进程控制块(process control block)的数据结构中，控制块由操作系统创建和管理。系统通过 PCB 感知进程的存在，并对其进行有效管理和控制。系统创建一个新进程时，为它建立一个PCB；当进程结束时，系统又收回其PCB，该进程也随之消亡。



## 进程创建

操作系统决定创建一个新进程时，会按如下步骤操作:  

1. 为新进程分配一个唯一的进程标识符。此时，主进程表中会添加一个新表项，每个进程一个表项。
2. 为进程分配空间。这包括进程映像中的所有元素。因此，操作系统必须知道私有用户地址空间(程序和数据)和用户栈需要多少空间。
3. 初始化进程控制块。进程表示部分包括进程id和其他相关的id，如父进程id等。处理器状态信息部分的多数项目通常初始化为0，但程序计数器(置为程序入口点)和系统栈指针(定义进程栈边界)除外。进程控制信息部分根据标准的默认值和该进程请求的特性来初始化。例如，进程的状态通常初始化为就绪或就绪/挂起。
4. 设置正确的链接。例如，若操作系统将每个调度队列都维护为一个链表，则新进程必须放在继续或就绪/挂起链表中。
5. 创建或扩充其他数据结构。例如，操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件。



## 进程切换

操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 进程表(process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。

**操作系统最底层的就是调度程序**，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。

表面上看，进程切换很简单。在某个时刻，操作系统中断一个正在运行的进程，将另一个进程置于运行模式，并把控制权交给后者。然而，这会引发若干个问题。首先，什么事件触发了进程的切换？ 其次，必须认识到模式切换和进程切换键的区别。



进程切换可在操作系统从当前正运行进程中获得控制权的任何时刻发生。首先考虑系统终端。实际上，大多数操作系统都会区分两种系统终端：一种称为终端，另一种称为陷阱。前者与当前正运行进程无关的某种外部事件相关，如完成一次I/O操作。后者与当前正运行进程产生的错误或异常条件相关，如非法的文件访问。对于普通终端，控制权首先转给终端处理器，终端处理器完成一些基本的辅助工作后，再将控制权给与已发生的特定中断相关的操作系统进程。示例如下:  

- 时钟中断：操作系统确定当前正运行进程的执行时间是否已超过最大允许时间段(时间片，即进程中断前可以执行的最大时间段)。若超过，进程就切换到就绪态，并调入另一个进程。
- I/O中断：操作系统确定是否已发生I/O活动。若I/O活动是一个或多个进程正在等待的事件，则操作系统就把所处于堵塞态的进程转换为就绪态( 堵塞/挂起态进程转换为就绪/挂起态)。操作系统必须决定是继续执行当前处于运行态的进程，还是让具有高优先级的就绪态进程抢占这个进程。
- 内存失效：处理器遇到一个引用不在内存中的字的虚存地址时，操作系统就必须从外村中把包含这一引用的内存块(页或段)调入内存。发出调入内存块的I/O请求后，内存失效进程将进入堵塞态。操作系统然后切换进程，恢复另一个进程的执行。期望的块调入内存后，该进程置为就绪态。

对于陷阱(trap)，操作系统则确定错误或异常条件是否致命。致命时，当前正运行进程置为退出态，并切换进程。不致命时，操作系统的动作将取决于错误的性质和操作系统的设计，操作系统可能会尝试恢复程序，或简单的通知用户。操作系统可能会切换进程或继续当前运行的进程。 



## 并发

在单处理器多道程序设计系统中，进程会被交替的执行，因而表现出一种并发执行的外部特征。即使不能实现真正的并行处理，并且在进程间来回切换也需要一定的开销，但是交替执行在处理效率和程序结构上还是会带来很多好处。在多处理系统中，不仅可以交替的执行进程，而且可以重叠执行进程。

进程的相对执行速度不可预测，它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略，这样就会有以下问题: 

1. 全局资源的共享充满了危险。例如，如果两个进程都使用同一个全局变量，并且都对该变量执行读写操作，那么不同的读写执行顺序是非常关键的。 
2. 操作系统很难对资源进行最优化分配。例如，进程A可能请求使用一个特定的I/O通道，并获取控制权，但它在使用这个通道前已被堵塞，而操作系统仍然锁定这个通道以防止其他进程使用，这是最难以令人满意的。事实上，这种情况有可能导致死锁。
3. 定位程序设计错误非常困难。这是因为结果通常是不确定的和不可再现的。

所以由于并发带来的这些问题，操作系统必须关注的问题如下: 

1. 操作系统必须能够跟踪不同的进程，这可以使用进程控制块来实现。
2. 操作系统必须为每个活动进程分配和释放各种资源。
3. 操作系统必须保护每个进程的数据和物理资源，避免其他进程的无意干扰。
4. 一个进程的功能和输出结果必须与执行速度无关。



### 互斥的要求

1. 必须强制实施互斥。在于相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。
2. 一个在非临界区停止的进程不能干涉其他进程。
3. 绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿。
4. 没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。
5. 对相关进程的执行速度和处理器的数量没有任何要求和限制。
6. 一个进程驻留在临界区中的时间必须是有限的。



## 进程间通信(Inter Process Communication，IPC)



进程间的信息交换，具体内容分为：控制信息交换和数据交换，控制信息的交换为低级通信，数据的交换为高级通信。

- 信号

    基本原来是：两个或多个进程可以通过简单的信号进行合作，可以强迫一个进程在某个位置停止，直到它接收到一个特定的信号。

- 共享存储系统

    多台服务器访问同一个存储设备的同一分区

- 消息传递系统

    进程与其它的进程进行通信而不必借助共享数据，通过互相发送和接收消息，建立一条通信链路。

- 管道通信

    发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信，管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据。每次只有一个进程能够真正地进入管道，其他的只能等待。

    管道分为无名管道和命名管道，前者用于父子进程通信，后者用于任意进程通信。



## 进程调度

进程调度就是处理器调度(上下文切换)

### 调度级别

- 高级调度

    作业调度,把后备作业调入内存运行

- 中级调度

    在虚拟存储器中引入，在内，外存交换区进行进程对换

- 低级调度

    进程调度，把就绪队列里的某个进程获得CPU执行权

### 调度方式

- 可剥夺

    当一个进程运行时，基于某种原则，剥夺已经分配给它的处理器，将之分配给其他进程，原则有：优先权原则，短进程优先原则，时间片原则。

- 不可剥夺

    一单处理器分配给某进程，遍让它一直运行下去，直到进程完成或者发生某种时间而阻塞，才分配给其他进程。

### 调度算法

- 先进先出

    按照进入就绪队列的进程顺序，不加其他条件干涉

- 短进程优先

    优先选出就绪队列中CPU执行时间最短的进程，例如：就绪队列有4个进程P1，P2，P3，P4，执行时间为：16,12,4,3 按照短进程优先，则周转时间(从进程提交到进程完成的时间间隔)分别为：35,19,7,3
    平均周转时间：16，平均周转时间越小，调度性能越好

- 轮转法
    - 简单轮转： 就绪进程按FIFO排队，按照一定时间间隔让处理机分配给队列中的进程，就绪队列中**所有队列均可获得一个时间片的处理器运行**
    - 多级队列： 让系统中所有进程分成若干类，每类一级

## 死锁

两个以上的进程相互请求对方已经占有的资源，导致无限期的等待。

### 产生条件

死锁有三个必要条件： 

- 互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。
- 占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。
- 不可抢占。不能强行抢占进程已占有的资源。

前三个条件都只是死锁存在的必要条件而非充分条件。要产生死锁，还需要第四个条件： 

- 循环等到。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。



### 解决方法

- 鸵鸟策略：不理睬
- 预防策略：破坏产生条件中任意一个
- 避免策略： 精心分配资源，动态避免死锁
- 检测与解除死锁：系统自动检测，并且解除



## Linux并发机制

Linux为进程间通信和同步提供了各种机制。这里只是几种。

- 管道

    管道是一个环形缓冲区，它允许两个进程以生产者/消费者的模型进行通信。因此，这是一个先进先出的队列，由一个进程写，由另一个进程度。

- 消息

    每个进程都有一个与之相关联的消息队列。当程序视图给一个满队列发送信息时，它会被堵塞。当进程视图从一个空队列读取消息时也回被堵塞。

- 共享内存

    这是虚存中由多个进程共享的一个公共内存块。进程读写共享内存所用的机器指令，与读写虚存空间的其他部分所用的指令相同。每个进程有一个只读或读写的权限。互斥约束不属于共享内存机制的一部分，但必须由使用共享内存的进程提供。

- 信号量

    信号量实际上是以集合的形式创建的，一个信号量集合中有一个或多个信号量。内核自动完成所有需要的操作，在所有操作完成前，任何其他进程都不能访问信号量。

    信号量由如下元素组成: 

    - 信号量的当前值
    - 在信号量上操作的最后一个进程的进程ID
    - 等待该信号量的值大于当前值的进程数
    - 等待该信号量的值为零的进程数

- 信号

    信号是用于向一个进程通知发生异步事件的机制。信号类似于硬件中断，但没有优先级，即内核公平地对待所有的信号。

- 自旋锁

    在Linux中保护临界区的常用技术是自旋锁。在同一个时刻，只有一个线程能够获得自旋锁。其他任何试图获得自旋锁的线程将一直进行尝试（即自旋），知道获得了该锁。



### Android进程间通信

虽然Linux内核包含很多用于进程间通信（IPC）的机制，但是Adnroid系统在IPC中仍然新增了一个连接器。连接器提供了一个轻量级的远程程序调用功能，它在内存和事务处理方面非常高效，非常适合嵌入式系统。

连接器被用来传递两个进程之间的交互。进程（客户端）组件发起一个调用，调用直接传递给位于内核的连接器，连接器将其传递给目标进程（服务器端）的目标组件，目标进程返回的结果通过连接器传递给发起调用的进程组件。



## Android进程结构

如同传统的Linux系统一样，Android的第一个用户空间进程是init，它是所有其他进程的根。然而，Android的init启动的守护进程是不同的，这些守护进程更多的聚焦于底层细节（管理文件系统和硬件访问），而不是高层用户设施，例如调度定时任务。Android还有一层额外的进程，它们运行Dalvik的Java语言环境，负责执行系统中所有以Java实现的部分。



![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_process.png?raw=true)



如上图，首先是init进程，它产生了一些底层守护进程，init进程是所有用户进程的鼻祖。其中一个守护进程是zygote，它是高级Java语言进程的根。Android的init不以传统的方法运行shell，因为典型的Android设备没有本地控制台用于shell访问。作为替代，系统进程adbd监听请求shell访问的远程连接（例如通过USB），按要求为它们创建shell进程。因为Android大部分是用Java语言编写的，所以zygote守护进程以及由它启动的进程是系统的中心。由zygote启动的第一个进程称为system_server，它包含全部核心操作服务，其关键部分是电源管理、包管理、窗口管理和活动管理。

其他进程在需要的时候由zygote创建。这些进程中有一些是“持久的”进程，它们是基本操作系统的组成部分，例如phone进程中的电话栈，它必须保持始终运行。另外的应用程序进程将在系统运行的过程中按需创建和终止。

应用程序通过调用操作系统提供的库与操作系统进行交互，这些库合起来构成Android框架（Android framework）。这些库中有一些可以在进程内部执行其工作，但是许多库需要与其他进程执行进程间通信，作者通常是在system_server进程中提供服务的。



### Zygote

系统中运行的第一个Dalvik虚拟机程序叫做zygote，该名称的意义是“一个卵”，因为接下来的所有Dalvik虚拟机进程都是通过这个卵孵化出来的。Zygote是在启动时就运行在DVM上的一个进程。

zygote进程汇总包含两个主要模块，分别如下:   

- Socket服务端：该Socket服务端用于接收启动新的Dalvik进程的命令。
- Framework共享类及共享资源。当zygote进程启动后，会装载一些共享的类及资源，其中共享类是在preload-classes文件中被定义，共享资源是在preload-resources中被定义。因为zygote进程用于孵化出其他Dalvik进程，因此，这些类和资源装载后，新的Dalvik进程就不需要再装载这些类和资源了，这也就是所谓的共享。



每当出现创建进程的请求时，Zygote就会产生一个新的DVM虚拟机。Zygote通过在内存中尽可能多的共享内容来最小化产生一个新DVM所消耗的时间。通常而言，许多应用程序都会使用核心库的类和相应的堆结构，而这些内容都是只读的。也就是说，被大部分应用程序使用的这些共享数据和类都是只读而不能改变的。因此，当Zygote加载时，就预加载和初始化了应用程序运行时可能用到的Java核心库和资源。当Zygote创建一个新的DVM时，这部分类不会被分配到新内存。Zygote只是简单地把子进程的这些内存页映射到父进程的相应位置。

实际上，几乎不需要更多的映射页。如果一个类被一个子进程自己的DVM改写，那么Zygote会将受影响的内存复制到子进程中。这种即写即复制的行为在使得最大化共享内存的同时，还能保证应用程序间不会相互影响，并在跨应用程序和进程的边界时保证安全性。

zygote进程对应的具体程序是app_process，该程序存在于system/bin目录下，启动该程序的指令是在init.rc中进行配置的。





#### System Server进程

System Server进程是由zygote进程fork而来，System Server是zygote孵化的第一个Dalvik进程，SystemServer仅仅是该进程的别名，而该进程具体对应的程序依然是app_process，因为System是从app_process中孵化出来的。System Server负责启动和管理整个Java framework，SystemServer进程在Android的运行环境中扮演了“神经中枢”的作用，APK应用中能够直接交互的大部分系统服务都在该进程中运行，常见的有WindowManagerServer（WmS）、ActivityManagerSystemService（AmS）、PackageManagerServer（PmS）等，这些系统服务都是以一个线程的方式存在于SystemServer进程中。SystemServer的main()函数会首先创建一个ServerThread对象，该对象是一个线程，然后直接运行该线程。而在ServerThread的run()方法内部真正启动各种服务线程，都有:  

- EntropyService：提供伪随机数
- PowerManagerService：电源管理服务
- ActivityManagerService：最核心的服务之一，管理Activity
- TelephonyRegistry：通过该服务注册电话模块的事件响应，比如重启、关闭、启动等
- PackageManagerService：程序包管理服务
- AccountManagerService：账户管理服务，是指联系人账户，而不是Linux系统账户
- ContentService：ContentProvider服务，提供跨进程数据交互
- BatteryService：电池管理服务
- LightsService：自然光强度感应传感器服务
- VibratorService：振动器服务
- AlarmManagerService：定时器管理服务，提供定时提醒服务
- WindowManagerService：Framework最核心的服务之一，负责窗口管理
- BluetoothService：蓝牙服务
- DevicePolicyManagerService：提供一些系统级别的设置及属性
- StatusBarManagerService：状态栏管理服务
- ClipboardService：系统剪切板服务
- InputMethodManagerService：输入法管理服务
- NetStatService：网络状态服务
- NetworkManagementService：网络管理服务
- ConnectivityService：网络连接管理服务
- NotificationManagerService：通知栏管理服务
- LocationManagerService：地理位置服务
- AudioService：音频管理服务
- ....

SystemServer中创建了一个Socket客户端，并有AmS负责管理该客户端，之后所有的Dalvik进程都将通过该Socket客户端间接被启动。当需要启动新的APK进程时，AmS中会通过该Socket客户端向zygote进程的Socket服务端发送一个启动命令，然后zygote会孵化出新的进程。





从系统架构的角度来看，先创建一个zygote并加载共享类的资源，然后通过该zygote去孵化新的Dalvik进程，该架构的特点有两个:    

- 每一个进程都是一个Dalvik虚拟机，而Dalvik虚拟机是一个类似于Java虚拟机的程序，并且从开发的过程来看，与标准的Java程序开发基本一致。因此对于程序员来讲，必须要学习新的语言，并可以使用Java程序在过去几十年中已经成熟的各种类库资源。
- zygote进程预先会装载共享类和共享资源，这些类及资源实际上就是SDK中定义的大部分类和资源，因此，当通过zygote孵化出新的进程后，新的APK进程只需要去装载APK自身包含的类和资源即可，这就有效的解决了多个APK共享Framework资源的问题。



## Android进程模型



Linux的传统进程模型是用fork指令来创建新进程，然后用exec指令使用待运行的源码初始化该进程并开始执行。shell负责实现进程执行、创建新进程、执行所需的进程来运行shell指令。当指令结束时，进程被从Linux中移除。

Android使用的进程有些不同。活动管理器是Android负责正在运行的应用程序的管理的一部分。活动管理器协调新应用程序进程的启动，决定哪些应用程序能在其中运行，哪些已不再需要。



### 启动进程

为了启动新进程，活动管理器需要与zygote通信。活动管理器首先开始，它创建一个与zygote相连的专用接口，通过接口发送一条指令，表示它需要启动一个进程。这条指令主要描述需要创建的沙箱、新进程运行所需要的UID以及需要遵守的安全性制约。zygote需要作为根来运行：创建新进程时，它合理配置运行所需的UID，最终下放权限，将进程改为该UID。

![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_start_process.png?raw=true)

上图展示了一个新进程中启动活动的流程： 

1. 某个现有进程（如应用程序启动器）调用活动管理器，发出意图，描述它想要启动的新活动。
2. 活动管理器要求封装管理器将这个意图解析为一个明确的组件。
3. 活动管理器判断这个应用程序的进程并未正在运行，然后向zygote请求一个具有合适UID的新锦成。
4. zygote进行一次fork指令，克隆自己来创造一个新进程，下方权限并配置新进程的UID和沙箱，初始化该进程的Dalvik，使得Java runtime开始完全执行。例如，它需要在fork后启动垃圾收集等线程。
5. 新进程如今是一个zygote的克隆，并运行着完全配置好的Java环境。它回调活动管理器，询问后者“我该做什么”。
6. 活动管理器返回即将启动的应用程序的完整信息，如源码位置等。
7. 新进程读取应用程序的源码，开始运行。
8. 活动管理器将所有即将进行的操作发送给新进程，在此处为“启动活动X”。
9. 新进程收到指令，启动活动，实体化合适的Java类并执行。

注意，当活动启动时，应用程序的进程可能正在运行了。在这种情况下，活动管理器会直接跳转到末尾，向该进程发送一条新指令，让它实体化并执行合适的组件。如果合适，这会导致一个额外的活动实例在应用程序中运行。





### 进程生命周期

活动管理器也负责判断何时进程不再被需要。活动管理器记录一个进程中运行的所有活动、接收器、服务以及内容提供其，据此可判断该进程的重要程度。

Android内核中的内存溢出强制结束指令是使用一个进程的oom_adj进行严格排序，决定哪个进程需要优先强制结束。活动管理器负责基于每个进程的状态，通过将其归类于几个主要用途，从而合理设定器oom_adj。/proc/<pid>/oom_adj:   

- 取值是-17到+15，取值越高，越容易被干掉。如果是-17，则表示不能被kill
- 该设置参数的存在是为了和旧版本的内核兼容

![img](https://raw.githubusercontent.com/CharonChui/Pictures/master/android_process_adj.png?raw=true)

让RAM内存不足时，系统已经完成了进程的配置，使得内存溢出强制结束命令优先中止缓存(cache)类型的进程，尝试重新取得足够的所需内存，随后中止界面(home)类别、服务(service)类别，以此类推。在同一个oom_adj水平中，它将优先中止内存占用较大的进程。



### Android系统启动的核心流程如下：



![](https://raw.githubusercontent.com/CharonChui/Pictures/master/Andriod-Boot-Process.jpg)



1. 启动电源以及系统启动：当电源按下时引导芯片从预定义的地方（固化在ROM）开始执行（Boot ROM），Boot ROM会去加载引导程序BootLoader到RAM，然后执行。

2. 引导程序BootLoader：BootLoader是在Android系统开始运行前的一个小程序，主要用于把系统OS拉起来并运行。
3. Linux内核启动：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当其完成系统设置时，会先在系统文件中寻找init.rc文件，并启动init进程。
4. init进程启动：初始化和启动属性服务，init进程会孵化出eadbd、logd、等用户守护进程，还会启动ServiceManager(binder服务管家)、botanic(开机动画)等服务，并且启动Zygote进程。
5. Zygote进程启动：zygote进程是Android系统的第一个Java进程（即虚拟机进程），它是所有Java进程的父进程。它会创建JVM并为其注册JNI方法，创建服务器端Socket，启动SystemServer进程。并且，zygote进程在启动的时候会创建DVM或者ART。因此通过从zygote进程fork创建的应用程序进程和systemserver进程都可以在内部获取一个DVM或者ART的实例副本。它还会提前加载类preloadClasses和提前加载资源preloadResouces。
6. SystemServer进程启动：System Server是zygote孵化的第一个进程，它会启动Binder线程池和SystemServiceManager，并且启动各种系统服务，包括ActivityManager、WindowManager、PackageManager、PowerManager等服务。
7. Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包括AudioFlinger，Camera Service等服务。
8. Launcher启动：是zygote孵化的第一个App进程，被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到系统桌面上。zygote还会创建Broweer、Phone、Email等App进程，每个App至少运行在一个进程上。



对于IPC(Inter-Process Communication,  进程间通信)，Linux现有管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制，Android额外还有Binder  IPC机制，Android OS中的Zygote进程的IPC采用的是Socket机制，在上层system server、media  server以及上层App之间更多的是采用Binder  IPC方式来完成跨进程间的通信。对于Android上层架构中，很多时候是在同一个进程的线程之间需要相互通信，例如同一个进程的主线程与工作线程之间的通信，往往采用的Handler消息机制。



## 线程

多线程技术是指把执行一个应用程序的进程划分为可以同时运行的多个线程。



### 进程和线程的区别

进程有如下两个特点: 

-  资源所有权：进程包括存放进程映像的虚拟地址空间，进程映像是程序、数据、栈和进程控制块中定义的属性集。进程总具有对资源的控制权和所有权，这些资源包括内存、I/O通道、I/O设备和文件。操作系统能提供预防进程间发生不必要资源冲突的保护功能。
- 调度/执行：进程执行时采用一个或多程序的执行路径，不同进程的执行过程会交替执行。因此进程具有执行态和分配给其的优先级，是可被操作系统调度和分派的实体。

上面这两个特点是独立的，因此操作系统能分别处理它们。为了区分这两个特点，通常将分派的单位成为线程或轻量级进程，而将拥有资源所有权的单位成为进程或任务。

- 线程（thread）：可分派的工作单元。它包括处理器上下文环境（包含程序计数器和栈指针）和栈中自身的数据区域。线程顺序执行且可以中断，因此处理器可以转到另一个线程。
- 进程（process)：一个或多个线程和相关系统资源（如包含程序和代码的存储空间、打开的文件和设备）的集合。它严格对应于一个正在执行的程序的概念。通过把一个应用程序分解成多个线程，程序员可以很大程度上控制应用程序的模块性及相关事件的时间安排。

线程比进程更轻量级，所以它们比进程更容易（更快）创建，也更容易撤销。在许多系统中，创建一个线程比创建一个进程要快10~100倍。



进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
2. 线程的划分尺度小于进程，使得多线程程序的并发性高。
3. 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。



- [上一篇:1.操作系统简介](https://github.com/CharonChui/AndroidNote/blob/master/OperatingSystem/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B.md)

- [下一篇:2.进程与线程](https://github.com/CharonChui/AndroidNote/blob/master/OperatingSystem/2.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md)


---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
